# åŸºäºTD3ç®—æ³•çš„è¾¹ç¼˜è®¡ç®—èµ„æºåˆ†é…ä¼˜åŒ–

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æå‡ºäº†ä¸€ç§åŸºäº**Twin Delayed Deep Deterministic Policy Gradient (TD3)**ç®—æ³•çš„è¾¹ç¼˜è®¡ç®—èµ„æºåˆ†é…ä¼˜åŒ–æ–¹æ¡ˆã€‚é’ˆå¯¹ç§»åŠ¨è¾¹ç¼˜è®¡ç®—(MEC)ç¯å¢ƒä¸­çš„è®¡ç®—å¸è½½ã€èµ„æºåˆ†é…å’Œä»»åŠ¡è°ƒåº¦é—®é¢˜ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªæ™ºèƒ½åŒ–çš„èµ„æºç®¡ç†ç³»ç»Ÿï¼Œèƒ½å¤ŸåŠ¨æ€ä¼˜åŒ–è®¡ç®—èµ„æºåˆ†é…ã€å¸¦å®½åˆ†é…å’Œå¸è½½å†³ç­–ï¼Œä»¥æœ€å°åŒ–ç³»ç»Ÿæ€»å»¶è¿Ÿå’Œèƒ½è€—ã€‚

![è¾¹ç¼˜è®¡ç®—æ¶æ„](image/Summary.png)

## æ ¸å¿ƒåˆ›æ–°

### ğŸš€ **TD3ç®—æ³•åœ¨è¾¹ç¼˜è®¡ç®—ä¸­çš„åº”ç”¨**
- **é¦–æ¬¡å°†TD3ç®—æ³•**åº”ç”¨äºè¾¹ç¼˜è®¡ç®—èµ„æºåˆ†é…é—®é¢˜
- **ç›®æ ‡ç­–ç•¥å¹³æ»‘**ï¼šå‡å°‘Qå€¼ä¼°è®¡åå·®ï¼Œæé«˜è®­ç»ƒç¨³å®šæ€§
- **å»¶è¿Ÿç­–ç•¥æ›´æ–°**ï¼šé™ä½ç­–ç•¥æ›´æ–°é¢‘ç‡ï¼Œé¿å…è¿‡åº¦æ‹Ÿåˆ
- **åŒQç½‘ç»œæ¶æ„**ï¼šä½¿ç”¨ä¸¤ä¸ªç‹¬ç«‹çš„Criticç½‘ç»œï¼Œå–æœ€å°å€¼ä½œä¸ºç›®æ ‡Qå€¼

### ğŸ¯ **å¤šç›®æ ‡ä¼˜åŒ–è®¾è®¡**
- **å»¶è¿Ÿæœ€å°åŒ–**ï¼šä¼˜åŒ–ä»»åŠ¡ä¼ è¾“å’Œè®¡ç®—å»¶è¿Ÿ
- **èƒ½è€—ä¼˜åŒ–**ï¼šå¹³è¡¡ä¼ è¾“èƒ½è€—å’Œè®¡ç®—èƒ½è€—
- **èµ„æºåˆ©ç”¨ç‡æœ€å¤§åŒ–**ï¼šåŠ¨æ€åˆ†é…è¾¹ç¼˜æœåŠ¡å™¨è®¡ç®—èµ„æº

## ç³»ç»Ÿæ¶æ„

### è¾¹ç¼˜è®¡ç®—ç¯å¢ƒ

#### ç§»åŠ¨ç”¨æˆ· (Mobile Users)
- **ç”¨æˆ·æ•°é‡**ï¼š10ä¸ªç§»åŠ¨ç”¨æˆ·
- **ç§»åŠ¨æ¨¡å¼**ï¼šåŸºäºKAISTæ•°æ®é›†çš„çœŸå®ç§»åŠ¨è½¨è¿¹
- **ä»»åŠ¡ç±»å‹**ï¼šVOC SSD300ç›®æ ‡æ£€æµ‹ä»»åŠ¡
- **ä»»åŠ¡å‚æ•°**ï¼š
  - ä¼ è¾“æ•°æ®å¤§å°ï¼š2.7 Ã— 10â´ bytes
  - å¤„ç†æ•°æ®å¤§å°ï¼š1.08 Ã— 10â¶ bytes
  - è¿”å›æ•°æ®å¤§å°ï¼š96 bytes

#### è¾¹ç¼˜æœåŠ¡å™¨ (Edge Servers)
- **æœåŠ¡å™¨æ•°é‡**ï¼š10ä¸ªè¾¹ç¼˜æœåŠ¡å™¨
- **è®¡ç®—èƒ½åŠ›**ï¼š6.3 Ã— 10â· byte/sec
- **å¸¦å®½å®¹é‡**ï¼š1 Ã— 10â¹ byte/sec
- **æœåŠ¡é™åˆ¶**ï¼šæ¯ä¸ªæœåŠ¡å™¨æœ€å¤šæœåŠ¡4ä¸ªç”¨æˆ·

### TD3æ™ºèƒ½ä½“è®¾è®¡

#### çŠ¶æ€ç©ºé—´ (State Space)
```python
# çŠ¶æ€ç»´åº¦ï¼šuser_num * 2 + 3 = 23
state = [
    # è¾¹ç¼˜æœåŠ¡å™¨å¯ç”¨èµ„æº (10ç»´)
    edge_resources,
    # å¯ç”¨å¸¦å®½ (10ç»´)  
    available_bandwidth,
    # ç”¨æˆ·å¸è½½ç›®æ ‡ (10ç»´)
    offloading_targets,
    # ç”¨æˆ·ä½ç½® (20ç»´)
    user_locations,
    # ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡ (3ç»´)
    [delay, energy, cost]
]
```

#### åŠ¨ä½œç©ºé—´ (Action Space)
```python
# åŠ¨ä½œç»´åº¦ï¼šuser_num * (edge_num + 1) + user_num + edge_num * user_num = 130
action = [
    # å¸è½½å†³ç­– (110ç»´)
    offloading_decisions,
    # ä¼ è¾“åŠŸç‡ (10ç»´)
    transmission_power,
    # è®¡ç®—èµ„æºåˆ†é… (100ç»´)
    resource_allocation
]
```

#### å¥–åŠ±å‡½æ•° (Reward Function)
```python
reward = 1 / cost
# cost = w1 * delay + w2 * energy
# å…¶ä¸­ w1 = w2 = 0.5
```

## ç®—æ³•å®ç°

### TD3ç½‘ç»œæ¶æ„

#### Actorç½‘ç»œ (ç­–ç•¥ç½‘ç»œ)
```python
def get_actor():
    inputs = layers.Input(shape=(num_states,))
    out = layers.Dense(400, activation="relu")(inputs)
    out = layers.Dense(300, activation="relu")(out)
    outputs = layers.Dense(num_actions, activation="tanh")(out)
    return model
```

#### Criticç½‘ç»œ (ä»·å€¼ç½‘ç»œ)
```python
def get_critic():
    state_input = layers.Input(shape=(num_states))
    action_input = layers.Input(shape=(num_actions))
    state_out = layers.Dense(400, activation="relu")(state_input)
    action_out = layers.Dense(400, activation="relu")(action_input)
    concat = layers.Concatenate()([state_out, action_out])
    out = layers.Dense(300, activation="relu")(concat)
    outputs = layers.Dense(1)(out)
    return model
```

### TD3æ ¸å¿ƒç‰¹æ€§

#### 1. ç›®æ ‡ç­–ç•¥å¹³æ»‘ (Target Policy Smoothing)
```python
# åœ¨ç›®æ ‡åŠ¨ä½œä¸Šæ·»åŠ å™ªå£°
target_actions = target_actor(next_state_batch, training=True)
noise = tf.random.normal(target_actions.shape, 0, 0.2)
noise = tf.clip_by_value(noise, -0.5, 0.5)
target_actions = tf.clip_by_value(target_actions + noise, -1, 1)
```

#### 2. å»¶è¿Ÿç­–ç•¥æ›´æ–° (Delayed Policy Updates)
```python
# æ¯2æ­¥æ›´æ–°ä¸€æ¬¡ç­–ç•¥ç½‘ç»œ
if self.buffer_counter % 2 == 0:
    # æ›´æ–°Actorç½‘ç»œ
    actor_loss = -tf.math.reduce_mean(critic_value)
```

#### 3. åŒQç½‘ç»œ (Twin Q-Networks)
```python
# ä½¿ç”¨ä¸¤ä¸ªç‹¬ç«‹çš„Criticç½‘ç»œ
y1 = reward_batch + gamma * target_1_critic([next_state_batch, target_actions])
y2 = reward_batch + gamma * target_2_critic([next_state_batch, target_actions])
min_q_target = tf.minimum(y1, y2)
```

## å®éªŒè®¾ç½®

### è®­ç»ƒå‚æ•°
- **æ€»è®­ç»ƒè½®æ•°**ï¼š500 episodes
- **æ¯è½®æ­¥æ•°**ï¼š3000 steps
- **å­¦ä¹ ç‡**ï¼šActor=3e-4, Critic=3e-4
- **æŠ˜æ‰£å› å­**ï¼šÎ³ = 0.99
- **ç›®æ ‡ç½‘ç»œæ›´æ–°ç‡**ï¼šÏ„ = 0.005
- **ç»éªŒç¼“å†²åŒº**ï¼š100,000å®¹é‡
- **æ‰¹æ¬¡å¤§å°**ï¼š256

### ç¯å¢ƒå‚æ•°
- **ç”¨æˆ·æ•°é‡**ï¼š10ä¸ª
- **è¾¹ç¼˜æœåŠ¡å™¨æ•°é‡**ï¼š10ä¸ª
- **å¸¦å®½**ï¼š1 Ã— 10â¹ byte/sec
- **è®¡ç®—èƒ½åŠ›**ï¼š6.3 Ã— 10â· byte/sec
- **ä¼ è¾“åŠŸç‡**ï¼š500 mW
- **é—²æ—¶åŠŸç‡**ï¼š100 mW

## è¿è¡ŒæŒ‡å—

### ç¯å¢ƒè¦æ±‚
```bash
Python 3.7.5+
TensorFlow 2.2.0+
NumPy
Matplotlib
TensorboardX
```

### è¿è¡ŒTD3ç®—æ³•
```bash
# è¿è¡ŒTD3è®­ç»ƒ
python src/td3_mec.py

# æŸ¥çœ‹è®­ç»ƒæ—¥å¿—
tensorboard --logdir=tensorboard_data
```

### å‚æ•°é…ç½®
```python
# åœ¨td3_mec.pyä¸­ä¿®æ”¹å‚æ•°
user_num = 10          # ç”¨æˆ·æ•°é‡
edge_num = 10          # è¾¹ç¼˜æœåŠ¡å™¨æ•°é‡
total_episodes = 500   # è®­ç»ƒè½®æ•°
buffer_size = 100000   # ç¼“å†²åŒºå¤§å°
batch_size = 256       # æ‰¹æ¬¡å¤§å°
```

## æ€§èƒ½è¯„ä¼°

### è¯„ä¼°æŒ‡æ ‡
1. **ç³»ç»Ÿæ€»å»¶è¿Ÿ**ï¼šä»»åŠ¡ä¼ è¾“å’Œè®¡ç®—çš„æ€»æ—¶é—´
2. **ç³»ç»Ÿæ€»èƒ½è€—**ï¼šä¼ è¾“å’Œè®¡ç®—çš„æ€»èƒ½è€—
3. **èµ„æºåˆ©ç”¨ç‡**ï¼šè¾¹ç¼˜æœåŠ¡å™¨è®¡ç®—èµ„æºçš„åˆ©ç”¨æ•ˆç‡
4. **ä»»åŠ¡å®Œæˆç‡**ï¼šæˆåŠŸå®Œæˆçš„ä»»åŠ¡æ¯”ä¾‹

### å¯¹æ¯”åŸºå‡†
- **DDPGç®—æ³•**ï¼šæ·±åº¦ç¡®å®šæ€§ç­–ç•¥æ¢¯åº¦
- **PPOç®—æ³•**ï¼šè¿‘ç«¯ç­–ç•¥ä¼˜åŒ–
- **SACç®—æ³•**ï¼šè½¯æ¼”å‘˜è¯„è®ºå®¶
- **ä¼ ç»Ÿå¯å‘å¼æ–¹æ³•**ï¼šåŸºäºè·ç¦»çš„æœ€è¿‘æœåŠ¡å™¨åˆ†é…

## é¡¹ç›®ç»“æ„

```
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ td3_mec.py          # TD3ç®—æ³•ä¸»å®ç°
â”‚   â”œâ”€â”€ mec.py              # è¾¹ç¼˜è®¡ç®—ç¯å¢ƒ
â”‚   â”œâ”€â”€ env.py              # åŸå§‹ç¯å¢ƒå®ç°
â”‚   â””â”€â”€ model/              # å¼ºåŒ–å­¦ä¹ ç®—æ³•é›†åˆ
â”‚       â”œâ”€â”€ ppo.py          # PPOç®—æ³•
â”‚       â”œâ”€â”€ sac.py          # SACç®—æ³•
â”‚       â”œâ”€â”€ dqn.py          # DQNç®—æ³•
â”‚       â”œâ”€â”€ a2c.py          # A2Cç®—æ³•
â”‚       â””â”€â”€ trpo.py         # TRPOç®—æ³•
â”œâ”€â”€ data/                   # KAISTç§»åŠ¨è½¨è¿¹æ•°æ®
â”œâ”€â”€ output/                 # å®éªŒç»“æœ
â””â”€â”€ image/                  # é¡¹ç›®å›¾ç‰‡
```

## ä¸»è¦è´¡çŒ®

### 1. **ç®—æ³•åˆ›æ–°**
- é¦–æ¬¡å°†TD3ç®—æ³•åº”ç”¨äºè¾¹ç¼˜è®¡ç®—èµ„æºåˆ†é…
- è®¾è®¡äº†é€‚åˆè¾¹ç¼˜è®¡ç®—ç¯å¢ƒçš„çŠ¶æ€å’ŒåŠ¨ä½œç©ºé—´
- å®ç°äº†å¤šç›®æ ‡ä¼˜åŒ–çš„å¥–åŠ±å‡½æ•°

### 2. **ç³»ç»Ÿä¼˜åŒ–**
- åŠ¨æ€èµ„æºåˆ†é…ç­–ç•¥
- æ™ºèƒ½å¸è½½å†³ç­–æœºåˆ¶
- å®æ—¶æ€§èƒ½ç›‘æ§å’Œè°ƒæ•´

### 3. **å®éªŒéªŒè¯**
- åŸºäºçœŸå®ç§»åŠ¨è½¨è¿¹æ•°æ®çš„ä»¿çœŸ
- å¤šåœºæ™¯æ€§èƒ½å¯¹æ¯”åˆ†æ
- ç®—æ³•æ”¶æ•›æ€§å’Œç¨³å®šæ€§éªŒè¯

## æœªæ¥å·¥ä½œ

1. **å¤šæ™ºèƒ½ä½“TD3**ï¼šæ‰©å±•åˆ°å¤šæ™ºèƒ½ä½“åä½œåœºæ™¯
2. **åœ¨çº¿å­¦ä¹ **ï¼šå®ç°å®æ—¶åœ¨çº¿å­¦ä¹ å’Œé€‚åº”
3. **å¼‚æ„ç¯å¢ƒ**ï¼šæ”¯æŒä¸åŒç±»å‹çš„è¾¹ç¼˜è®¾å¤‡å’Œä»»åŠ¡
4. **å®‰å…¨æœºåˆ¶**ï¼šåŠ å…¥éšç§ä¿æŠ¤å’Œå®‰å…¨æ€§è€ƒè™‘

## å‚è€ƒæ–‡çŒ®

1. Fujimoto, S., van Hoof, H., & Meger, D. (2018). Addressing function approximation error in actor-critic methods. *ICML*.
2. Han, M., et al. (2008). CRAWDAD dataset kaist/wibro. *CRAWDAD*.
3. Liu, L., et al. (2016). Mobile edge computing: A survey on the hardware-software reference architecture. *ACM Computing Surveys*.

## è”ç³»æ–¹å¼

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»ï¼š
- é¡¹ç›®åœ°å€ï¼š[GitHub Repository]
- é‚®ç®±ï¼š[your-email@example.com]

---

**æ³¨æ„**ï¼šæœ¬é¡¹ç›®ä»…ç”¨äºå­¦æœ¯ç ”ç©¶ç›®çš„ï¼Œè¯·å‹¿ç”¨äºå•†ä¸šç”¨é€”ã€‚
